<script>
	1,template(组件注册及嵌套)
	{
		import Vue from 'vue'

		var myHeaderChild = {
			template: '<p>小五是二货</p>'
		}

		var myHeader = {
			template: '<p><my-header-child></my-header-child>小白是傻屌</p>',
			components: {
				'my-header-child': myHeaderChild
			}
		}

		new Vue({
			el: '#app',
			data: {
				word: 'hello world'
			},
			components: {
				'my-header': myHeader
			}
		})

		//使用
		<div id="app">
	    <my-header></my-header>
	  </div>

	}

	2,data注意:以下写法可以避免组件多次使用时数据的污染
	{
		data: function() {
			return {
				five: '2货',
				white: '傻屌'
			}
		}
	}

	3, v-on:keydown.enter=""
	{
		enter键按下后触发
	}

	4,在vue里v-for循环的是本身,不是子元素。v-for(value, index)

	5,v-show相当于 display:none;而v-if 相当于删除了dom节点

	6,表单通过v-model绑定
	{
		v-model.number: 值为数字类型
		v-model.lazy: 完成后执行，不会跟着输入自动更新
		v-model.trim: 自动去掉输入的空格
	}

	7,计算属性computed: 相当于data,但能通过函数,用返回值进行赋值
	{
		计算属性是被缓存的，如果在方法中调用，每次调用都会从新计算
	}

	8,属性监听watch: 值被更改触发特定事件,参数可传可不传,用法比如在删除添加等操作触发相同的表单事件,用watch更方便
	{
		watch: {
			myval: function(value, oldvalue) {
				执行语句
			}
		}
	}

	9,组件注册: components中注册为驼峰式,而通过标签名引入时为小写字母与连接符“-”,vue2.0取消了这个限制

	10,通过is渲染组件,可以动态改变组件（动态组件）
	{
		'<p :is="comToRender"></p>'

		components: {
			comA,
			comB
		},
		data() {
			return {
				comToRender: 'com-a'
			}
		}

		如果使用标签'<keep-alive></keep-alive>'可以在切换时将变量缓存起来，提高加载速度
	}

	11,父组件向子组件props,子组件向父组件emit
	{
		props接收两种类型的参数，数组和对象
		通过对象方式可以声明属性的类型
		props:{
			'to-render': [Number, String, Object]
		}

		props: {
		  items: {  // 必须提供字段
		    required: true
		  },
		  unit: {   // 可选字段，有默认值
		    default: 3
		  }
		}
	}

	12,插槽slot 在父组件写入的值，可以通过插槽插入子组件中
	{
		如果在插槽标签里写了值，则在父组件中没有值传递时会调用子组件slot中的值
		子组件中可以通过name方式命名插槽 eg:'<slot name="header"><p>菜B小师父</p></slot><slot name="fotter"><p>菜B小师父</p></slot>'
		父组件可以通过如'<p slot="header">111</p>'来指定
	}

	13,没写div会报错，除非用v-if判断，报错原因挂载点
	{
		// <template>
		// 	<div></div>
		// </template>
	}

	14,过渡'<transition name="fade"></transition>'
	{
		1,css改变，对应四个阶段，fade是自定义name名称
		{
			0 -> 1
			fade-enter
			fade-enter-active

			1 -> 0
			fade-leave
			fade-leave-active
		}

		2,用v-if和v-show时不要忘了在data里给默认值

		3,默认mode="in-out",当使用v-bind控制时改为mode="out-in"可以平滑过渡

		4,使用v-if和v-else过渡时相同标签名必须定义不同key值加以区分,否则不会执行过渡动画

		5,js控制过渡（见vue文档或后续补充）
	}

	15,自定义指令，binding是一个对象，例如用自定义指令实现input聚焦
	{
		'<p v-color="'red'">123</p>'

		directives: {
			color: function(el, binding) {
				el.style.color = binding.value
			}
		}

		想要全局调用就写在main.js中
	}

	16,路由参数
	{
		可以通过path进行传参，如'apple/:color',如果写了参数，那访问时就必须要加入参数
		调用:this.$route.params

		嵌套路由以路由的格式写在父路由中
	}	

	17,多个按钮改变class的方式
	{
		(v-for="(item, index) of tagArr")
    (:class="index===activeTag ? 'checkedTag' : 'tag'")
		(@click="checkTag(index)">{{item}})

		activeTag: null

		checkTag(item) {
			this.activeTag = item
		}
	}

	18,滚动条
	{
		scrolled: false

		mounted () {
		  window.addEventListener('scroll', this.handleScroll)
		},

		handleScroll () {
	    if(window.scrollY > 50) {
	    	this.screenTop = 0
	    }

	    else if(window.scrollY <= 50) {
	    	this.screenTop = 50 - window.scrollY
	    }
	  },
	}

	19,动态生成的样式可通过模板字符串
	{
		:style="`background: linear-gradient(to top right,${item.startColor},${item.endColor})`"
	}

	20,动态class
	{
		:class="{ 'my-button-cut' : isTplCut }"
	}

	21,hover事件
	{
		@mouseenter="enter" 
		@mouseleave="leave"
	}

	22,原生js或jquery中DOM节点写入模板字符串报错
	{
		DOM节点中用模板字符串就不要再加引号
	}

	23,前端路由携带id
	{
		this.$router.push({ name: 'brandAdd', query: { id: id }})
	}

	24,QRcode使用：找不到属性要么改源码要么去控制台看下，然后remove掉
	{
		$(`#QRCode${index}`).html('')
		new QRCode(document.getElementById(`QRCode${index}`), {
  		text: `${initData.api}/open/admin/editorPreview/beid/${beid}#/preview?beid=${beid}&tplId=${tplId}&pageId=${pageId}`,
  		colorDark: '#fff',
  		colorLight: '#000',
      width: 120, 
      height: 120,
    })
    $(`#QRCode${index}`).removeAttr("title")
	}

	25,webpack-dev-server CLI项目搭建 取消直接跳转页面
	{
		在package.json中，重要的事说三遍
	}

	26,前端路由的缺点
	{
		不利于SEO
		前进和后退时不能合理利用缓存
		无法在前进后退时记住滚动位置
	}

	27,前端路由使用记录
	{
		'<router-link></router-link>':相当于a标签，在事件中使用this.$router.push({path:''}) 不支持target="_blank"属性
		'<router-view></router-view>':渲染路径匹配到的视图组件

		$router.params:查看路由参数
		改变路由模式：mode:"hash",mode:"history"
		children:[{path:'title'}]:定义子路由

		编程式路由：{
			$router.push('name')
			$router.push({path:'name'})
			$router.push({path:'name?a=123'})
			$router.push({parh:'name',query:{id:id}})
			$router.go(1) $router.go(-1)

			获取:$route.qurey.variable
		}
	}

	28,模板字符串跳转
	{
		window.location.href = `${initData.api}/open/admin/editor/beid/${initData.beid}#edit?tplId=${this.tplStoreId}`
	}

	29,多种状态时style
	{
		:style="getMyTplStyle(index, activeTag, itemActive)"
		getMyTplStyle(index, activeTag, itemActive){
			if(index === itemActive) {
				return 'color:#aaa;cursor:not-allowed;'
			}

			if(index === activeTag) {
				return 'color:#ea8716'
			} else {
				return 'cursor:not-allowed;color:#fff;'
			}
		},
	}

	30,webpack绝对路径设置('./'还是'../'看文件__dirname所在位置)
	{
		resolve: {
	    alias: {
	      'vue$': 'vue/dist/vue.esm.js',
	      'src': path.resolve(__dirname, './src'),
	      'components': path.resolve(__dirname, './src/components'),
	    },
	    extensions: ['*', '.js', '.vue', '.less', '.json']
	  },
	}

	31,动态渲染诸如iconfont这种特殊字符（'&#xe600;'）时，用v-html渲染

	32,在element-table中加入变量：
	{
		'<template scope="scope"></template>'
	}
</script>
